<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Elena Cortina Pino">
<meta name="description" content="A data storytelling module teaching students to use Closeread HTML to visualize data meaningfully.">

<title>Hot Dog Closeread</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="elena_final_hotdog_closearead_files/libs/clipboard/clipboard.min.js"></script>
<script src="elena_final_hotdog_closearead_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="elena_final_hotdog_closearead_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="elena_final_hotdog_closearead_files/libs/quarto-html/popper.min.js"></script>
<script src="elena_final_hotdog_closearead_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="elena_final_hotdog_closearead_files/libs/quarto-html/anchor.min.js"></script>
<link href="elena_final_hotdog_closearead_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="elena_final_hotdog_closearead_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="elena_final_hotdog_closearead_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="elena_final_hotdog_closearead_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="elena_final_hotdog_closearead_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="elena_final_hotdog_closearead_files/libs/quarto-contrib/intersection-observer-polyfill-1.0.0/intersection-observer.js"></script>
<script src="elena_final_hotdog_closearead_files/libs/quarto-contrib/scrollama-3.2.0/scrollama.min.js"></script>
<script src="elena_final_hotdog_closearead_files/libs/quarto-contrib/closeread-0.1.0/closeread.js"></script>
<meta cr-debug-mode="false">
<meta cr-remove-header-space="false">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="_extensions/qmd-lab/closeread/closeread.css">
</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-full">

<main class="content column-page" id="quarto-document-content">
      <!-- user-provided yaml closeread style options -->
      <style>
        :root {
          --cr-narrative-background-color-sidebar: #09753C;
--cr-narrative-text-color-sidebar: white;
        }
      </style>
    

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Hot Dog Closeread</h1>
<p class="subtitle lead">Using closeread HTML to tell the story of Nathan’s Hot Dog Eating Competition.</p>
</div>

<div>
  <div class="description">
    A data storytelling module teaching students to use Closeread HTML to visualize data meaningfully.
  </div>
</div>


<div class="quarto-title-meta column-page">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Elena Cortina Pino </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="notes-use-tennis-sample-size-module-template-to-fit-this-module-in" class="level3">
<h3 class="anchored" data-anchor-id="notes-use-tennis-sample-size-module-template-to-fit-this-module-in">Notes: use tennis sample size module template to fit this module in</h3>
</section>
<section id="in-this-demo-well-create-a-plot-with-data-from-the-wikipedia-page-for-the-story-of-nathans-hot-dog-eating-competition." class="level3">
<h3 class="anchored">In this demo, we’ll create a plot with data from the Wikipedia page for The Story of Nathan’s Hot Dog Eating Competition.</h3>
<p>Data was accessed from Wikipedia, “Nathan’s Hot Dog Eating Contest”, and cleaned with the R <code>tidyverse</code> library. (https://en.wikipedia.org/wiki/Nathan%27s_Hot_Dog_Eating_Contest).</p>
<div class="cr-section cr-column-screen sidebar-left">
<div class="narrative-col">
<div class="trigger new-trigger" data-focus-on="cr-final">
<div class="narrative">
<p>The Story of Nathan’s Hot Dog Eating Competition.</p>
</div>
</div>
<div class="trigger new-trigger" data-focus-on="cr-basicplot">
<div class="narrative">
<p>Let’s take a look at the development of this historical competition.</p>
</div>
</div>
<div class="trigger">
<div class="narrative">
<ul>
<li>First we set the stage for where the data points will be represented and explain the axes clearly with straightforward labeling.</li>
<li>The y-axis is already modified to account for standardization since the competitions across the years lasted different times. This was done with <code>dplyr</code> from <code>tidyverse</code>. The simple mathematics for the y-axis are: <span class="math inline">\(\text{Dogs per minute} = \frac{\text{Dogs eaten}}{\text{Event time}}\)</span></li>
</ul>
</div>
</div>
<div class="trigger">
<div class="narrative">
<p><br>
The Nathan’s Famous Fourth of July International Hot Dog Eating Contest has a 100+ year tradition. Over time, competitors have pushed the limits of human capacity in ways no one originally imagined.<br>
</p>
</div>
</div>
<div class="trigger new-trigger" data-focus-on="cr-points">
<div class="narrative">
<p>Now we can start the story from the beginning! (Let’s add the data points without formatting…)shows us the big picture for the historical timeline of winners across Nathan’s story. We added the points without formatting to be able to create a baseline from which to build up our descriptions of special aspects of the data-that’s the main goal for data storytelling in highlighting the meaningful from the seemingly unclear.</p>
</div>
</div>
<div class="trigger new-trigger" data-focus-on="cr-women">
<div class="narrative">
<p>can distinguish categories in the data by taking advantage of the <code>ggplot2</code> library. This particular data set does not include many categories that would allow us to see different dimensions of the data points. However, we can use the winners’ genders to highlight a breakthrough in the competitions , and can use that to our advantage to extrapolate the narrative to other competitive eating events, and changes they underwent to make competitions inclusive, or more fun!<br>
<br>
- Here we map the <code>color aesthetics</code> of the plot to distinguish between male and women in the competition with 2 different colors.<br>
<br>
- An interesting feature of this plot is the function <code>gghighlight</code> from the library <code>gghighlight</code>. This allows us to keep our other data points in the plot intact and highlight the points we want to highlight based on a specific feature without having to <code>filter</code>, <code>slice</code>, or <code>select</code> portions of our data to mae out the plot!</p>
</div>
</div>
<div class="trigger new-trigger" data-focus-on="cr-population">
<div class="narrative">
<p>Let’s take a closer look at the changes in the competition from 2011:art of annotation can be tactfully developed. Sometimes more is more, sometimes, an overwhelming amount of annotations in the plot can create confusion in the reader and distract from the main point.<br>
<br>
Use <code>text</code> and <code>label</code> <code>aesthetics</code> to distinguish between levels of importance in the annotations inside the plot.</p>
</div>
</div>
<div class="trigger">
<div class="narrative">
<p>Takeru Kobayashi introduced some serious techniques into his competitive eating. His strategy consisted of eating some cabbage and fasting before the contests. - This kind of commentary can complement what is happening inside the plot. There are many ways to explain that Takeru changed the game <em>while</em> highlighting that in the plot using a line (like done here), highlighting the point that corresponds to Takeru’s first win with a bright red diamond shaped point, etc…</p>
</div>
</div>
<div class="trigger new-trigger" data-focus-on="cr-code">
<div class="narrative">
<p>Here’s a look at the code that produces this annotated plot.</p>
</div>
</div>
<div class="trigger new-trigger" data-focus-on="cr-mikisudo">
<div class="narrative">
<p><br>
In the women’s category, Miki Sudo, native to Florida, is the overall champion.</p>
</div>
</div>
<div class="trigger new-trigger" data-focus-on="cr-final">
<div class="narrative">
<p>Taking a look at the general trend of the wins:</p>
</div>
</div>
<div class="trigger">
<div class="narrative">
<p>when it comes to making inferences on time series data like this one, it is easy to infer things that aren’t necessarily causal or follow a mathematical trend. Perhaps that is the distribution of the points for this particular data and that’s the information we have and work with. - Other data sets with independent variables other than <code>time</code> allow us to draw more nuanced interpretations on the relationships between the variables in out plot.</p>
</div>
</div>
<div class="trigger">
<div class="narrative">
<p>There seems to be a sinusoidal trend in the hot dog wins.<br>
<br>
- This comment could be something entirely different such as: “It seems like the amount of hot dogs competitive eaters can consume will begin flattening after a few more years.”</p>
</div>
</div>
<section id="exercise" class="level2 narrative trigger">
<h2 class="narrative anchored" data-anchor-id="exercise">Exercise</h2>
</section>
<div class="trigger new-trigger" data-focus-on="cr-exercise">
<div class="narrative">

</div>
</div>
<div class="trigger">
<div class="narrative">
<p>This is the solution plot for the exercise in this module. Many solutions possible. A correct plot includes:<br>
- Labeled axes for <code>x = year</code> and <code>y = dogs eaten per minute</code><br>
- Dot plot for all the observations in the data set.<br>
- Highlight for Joey Chestnut’s observations.<br>
- Different color and/or shape for Joey Chestnut’s observations.<br>
- Annotation that explains shortly which points correspond to Joey Chestnut’s wins.<br>
</p>
</div>
</div>
</div>
<div class="sticky-col">
<div class="sticky-col-stack">
<div id="cr-basicplot" class="sticky">
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="elena_final_hotdog_closearead_files/figure-html/basicplot-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</div>
<div id="cr-points" class="sticky">
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="elena_final_hotdog_closearead_files/figure-html/points-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</div>
<div id="cr-women" class="sticky">
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="elena_final_hotdog_closearead_files/figure-html/women-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</div>
<div id="cr-population" class="sticky">
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="elena_final_hotdog_closearead_files/figure-html/population-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</div>
<div id="cr-code" class="sticky">
<div class="line-block"><span id="lb1-1">ggplot(hotdog_clean_2) +</span><br>
<span id="lb1-2">&nbsp;&nbsp;aes(x = Year, y = standard) +</span><br>
<span id="lb1-3">&nbsp;&nbsp;geom_point(aes(colour = factor(Sex))) +</span><br>
<span id="lb1-4">&nbsp;&nbsp;scale_colour_manual(values = c(“#95F527”, “#01401C”)) +</span><br>
<span id="lb1-5">&nbsp;&nbsp;annotate(“label”, x = 1976, y = 6.8, label = “Women”, fill = “#95F527”) +</span><br>
<span id="lb1-6">&nbsp;&nbsp;annotate(“label”, x = 1976, y = 7.2, label = “Men”, fill = “#01401C”,</span><br>
<span id="lb1-7">&nbsp;&nbsp;color = “#FFFFFF”) +</span><br>
<span id="lb1-8">&nbsp;&nbsp;guides(colour = “none”, shape = “none”) +</span><br>
<span id="lb1-9">&nbsp;&nbsp;theme_minimal() +</span><br>
<span id="lb1-10">&nbsp;&nbsp;theme(legend.position = “none”) +</span><br>
<span id="lb1-11">&nbsp;&nbsp;labs(x = “Year”, y = “Dogs eaten per minute”) +</span><br>
<span id="lb1-12">&nbsp;&nbsp;geom_vline(xintercept = 2001, linetype = 1) +</span><br>
<span id="lb1-13">&nbsp;&nbsp;annotate(“text”, x = 2013, y = 1.5, size = 3.63,</span><br>
<span id="lb1-14">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label = “→ Takeru Kobayashi enters the game”)</span><br>
<span id="lb1-15"></span></div>
</div>
<div id="cr-mikisudo" class="sticky">
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="elena_final_hotdog_closearead_files/figure-html/mikisudo-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</div>
<div id="cr-final" class="sticky">
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="elena_final_hotdog_closearead_files/figure-html/final-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</div>
<div id="cr-exercise" class="sticky">
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="elena_final_hotdog_closearead_files/figure-html/exercise-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<p>Thank you for scrolling!</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>